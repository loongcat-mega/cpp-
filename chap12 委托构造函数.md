


## 冗余的构造函数

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240430205726.png)


根据不同构造情况调用不同的构造函数，代码维护困难

如果代理函数commoninit里面对字符串 等赋值了，就会产生多余开销
实际上它并不是一 个初始化过程，而是一个赋值过程。因为对象的初始化过程早在构造函 数主体执行之前，也就是初始化列表阶段就已经执行了

过去C++没有提供一种复用同类 型构造函数的方法，也就是说无法让一个构造函数将初始化的一部分工 作委托给同类型的另外一个构造函数。

## 委托构造函数

合理复用构造函数减少代码冗余，c++11支持了委托构造函数：某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化，前者为委托函数，后者为代理构造函数。委托构造函数会将控制权交给代理构造函数，**在代理构造函数执行完之后，再执行委托构造函数的主体**。

只需在委托构造函数的初始化列表中调用代理构造函数即可
如以下代码：
```cpp
class proxy
{
public:
    int a;
    double b;
    proxy():proxy(0){}
    proxy(int a):proxy(a,0){}
    proxy(double b):proxy(0,b){}
    proxy(int a,double b){commoninit(a,b);}
private:
    void commoninit(int aa,double bb)
    {
        this->a=aa;
        this->b=bb;
    }
};
```


- 每个构造函数都可以委托另一个构造函数为代理。也就是说， 可能存在一个构造函数，它既是委托构造函数也是代理构造函数
- 不要递归循环委托
- 如果一个构造函数为委托构造函数，那么其初始化列表里就不 能对数据成员和基类进行初始化
- 委托构造函数的执行顺序是先执行代理构造函数的初始化列 表，然后执行代理构造函数的主体，最后执行委托构造函数的主体

## 总结

为了解决构造函数冗余问题

通过委托构造函 数，我们可以有效地减少构造函数重复初始化数据成员的问题，将初始 化工作统一地交给某个构造函数来完成。这样在需要增减和修改数据成 员的时候就只需要修改代理构造函数即可


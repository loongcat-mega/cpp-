本仓库记录了现代c语言核心特性解析的一些笔记

利用命名空间可以在同一个文件内，写多个main函数，实现多个功能？类似于java类中的main？要调用那个，只需调用相应命名空间

auto+decltype+返回类型后置可以完成一些模版的编写和完善

右值引用引入了移动语义，由拷贝转为移动，节省了效率，std::move()可以让左值使用移动语义，完成内存的移动操作

lambda表达式个人多用在algorithm中的一些函数上，比如 sort ，find_if等

非静态数据成员默认初始化与委托构造函数都是针对成员的初始化问题，减少构造函数冗余

参数列表初始化多用在stl容器的初始化中

默认和删除函数让类具有某些特性，如不可拷贝，不可在堆空间生成等

一个类的构造函数可以用默认值初始化，如果想特化构造，可以使用委托代理构造极值，构造交给代理构造函数，减少赋值产生资源消耗

类的继承这块，子类构造函数，如果子类的聚合类型，则不需要构造函数，直接初始化列表构造。否则，可以引入继承构造机制，使用using引入基类构造函数。如果父类有虚函数，可以使用final来限定该虚函数不能被子类重写，在子类中使用override来表示这是重写的父类的虚函数

noexpect+static_assert可以解决移动构造可能带来的异常问题，先判断是否发生了异常，如果发生异常就执行B计划

对于变量别名这块，可以使用typedef，也可以使用using，using可以实现模版别名

NULL和nullptr空指针代表的含义不同


常量这块，尤其是编译期间能够确定的常量，可以使用constexpr，也可以使用字面量，用户也可以根据单位去自定义字面量


alignas使数据按指定长度对齐

为了方式隐式调用，可以使用explicit关键字对构造函数进行说明，阻止其隐式调用


可变参数模板，模板的传参，包括可以传入常量，匿名对象，局部对象，lambda表达式等。参数包的展开，可以是递归的，也可以使用折叠表达式



- chap2 内联和命名空间
  - 解决命名冲突问题
  - 更好省级维护代码
- chap3 auto占位符
  - 自动推导类型，但是c++20之前不能做形参
  - 与下面decltype和返回类型后置，使模版更加灵活易用
  - lambda表达式用auto接收
- chap4 decltype说明符
  - 根据规则获取操作数的类型
  - 对库作者友好
- chap5 函数返回类型后置
  - 与上面auto+decltype结合使用
- chap6 左值与右值引用
  - 右值不能取址
  - 函数返回值一般都是右值，可以初始化左值，但是当涉及类时，如果把一个右值传进左值引用的形参列表，会产生错误，解决方法：常量左值引用/右值引用
  - 右值引用引入了移动构造函数，因为右值生存期很短，没必要浪费时间再拷贝一份对象，所以可以直接移动资源，但可能会出现异常
  - 在右值初始化左值时，c++11默认会调用移动方式而不是拷贝方式
  - 左值属性变为右值可以提升效率
- chap7 lambda表达式
  - lambda是一个类，有着自己的成员属性
  - 捕获列表，只能捕获非静态局部变量
  - 按值/按引用捕获，按值不修改值(mutable)，按引用修改值
  - 与stl结合较多
- chap8 非静态数据成员默认初始化
  - 在定义时直接赋初值，减少了构造函数冗余问题
- chap9 列表初始化
  - 更多用在容器
  - 如果实在变量上，要注意隐式缩窄转换问题
- chap10 默认和删除函数
  - 精准控制类成员函数的生成和删除
  - 比如不允许一个类进行拷贝和赋值，就显式删除其相应构造函数
- chap12 委托构造函数
  - 解决构造函数冗余问题
  - 层层代理，委托构造函数让代理构造函数替自己完成构造，如果有新增参数，只需修改代理构造函数即可
- chap13 继承构造函数
  - 解决继承类构造函数代码冗余问题
  - 使用using关键字
- chap14 强枚举类型
  - 定义时使用class关键字
  - 使用时使用命名空间
- chap15 扩展的聚合类型
  - 满足聚合类的条件
  - 聚合类使用参数列表初始化(chap9)
  - 使用小括号初始化会有构造歧义
- chap16 override和final说明
  - override指示该函数是重写的父类的虚函数
  - final指示该虚函数/l类不能被子类重写/继承
  - 区分override overwrite overload
- chap17 基于范围的for循环
  - for(auto ele:container)
  - for(auto& ele:container)
  - for(const auto& ele:container),适用于非基础类型，减少拷贝
- chap18 支持初始化语句的if和switch
  - if(bool a=foo();a)
  - 用得少，先了解这个特性
- chap19 static_assert声明
  - 静态断言，在编译期完成，所以传入的参数是常量表达式
  - 当发生断言错误时，会直接报错
  - 与下面noexpect结合使用功能更强大
- chap20 noexpect关键字
  - 说明符和操作符
  - 用来指示函数(过程)是否会发生异常，如果不会，则输出true
  - 可以使用一些手段，使得当发生异常的时候执行B计划，前提是先知道能不能发生异常，就得noexpect嵌套
  - 典例：解决移动构造问题
  - 类自动生成的成员函数默认带有noexpect
- chap22 类型别名和别名模版
  - using定义别名
  - 别名模版：别名+模版
- chap23 指针字面量nullptr
  - 解决NULL=0带来的二义性问题
  - 是个nullptr_t类型的纯右值
  - 单纯的指针类型，可以向其他指针类型转换
- chap24 三向比较
- chap25 线程局部存储
- chap26 扩展的inline说明符
    - 不止能声明内联函数，还能初始化类内静态成员变量
- chap27 常量表达式
    - 使用constexpr进行声明，可以对值，对函数，对构造函数
    - 能够在编译期间就确定的值/函数返回值
- chap28 确定的表达式求值顺序
    - 函数表达式与函数参数的求值顺序
- chap29 字面量优化
    - 基础类型字面量
    - 十六进制进制浮点字面量
    - 二进制字面量
    - 原生字符串字面量
    - 用于自定义字面量，用于带有单位的值
- chap30 aliagns和alignof
    - alignas可以手动设置数据对齐大小
    - alignof可以获取对象的对齐长度
- chap31 属性说明符和标准属性
    - `[[attr]]` 提示编译器的东西
- chap32 新增预处理器和宏
- chap32 协程
- chap34 基础特性的其他优化
    - explicit 说明符作用于构造函数，不让其隐式调用，防止发生隐式类型转换
    - RVO与NRVO的优化，针对拷贝构造的优化
- chap35 可变参数模板
    - 类型模板形参包、函数形参包、形参包展开
    - 递归展开
    - 折叠表达式(一元/二元 向左/向右折叠)
- chap36 typename优化
    - 没太看明白
- chap37 模板参数优化
    - 允许常量求值做实参
    - 允许局部/匿名对象做实参
    - 允许函数模板的默认模板参数
    - 允许非类型模板形参中的字面量类型
- chap38 类模板的模版实参推导
    - 主要是一些不指定具体类型，让编译器去推导的东西
    - tuple的构造，自动去推导类型
    - 同类型列表初始化 拷贝初始化优先
    - lambda表达式作为实参




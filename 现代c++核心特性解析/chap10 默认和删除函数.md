

## 类的特殊成员函数

在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数
- 默认构造函数
- 析构函数
- 复制构造函数
- 赋值复制运算符函数
- 移动构造函数
- 移动赋值运算符函数


但是该特性会被影响：
- 声明任何构造函数都会抑制默认构造函数的添加
- 一旦用自定义构造函数代替默认构造函数，类就转换为非平凡类型

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240430204949.png)

有时候我们需要编 写一个禁止复制操作的类，但是过去C++标准并没有提供这样的能力。 聪明的程序员通过将复制构造函数和复制赋值运算符函数声明 为private并且不提供函数实现的方式，间接地达成目的

## 显式默认和显式删除

c++11提供了一种简单有效又精准控制默认特殊成员函数的添加和删除，将这种方法叫做显示默认和显式删除

函数的尾部添加=default和=delete，它们分别指示编译器添加特 殊函数的默认版本以及删除指定的函数


```cpp
class A
{
public:
    int a=10;
    string c="hello";
    A(int n):a(n){}
    A() =default;
    A(const A&)=delete;

    A& operator=(const A&) =delete;
    void * operator new(size_t) =delete;
};
```

上述代码，赋值复制操作符重载被显式删除，拷贝构造函数被显式删除，但是默认构造被显式添加

请注意，由于显式 地删除了复制构造函数，导致默认情况下编译器也不再自动添加默认构 造函数，因此我们必须显式地让编译器添加默认构造函数，否则会导致 编译失败。

=default可以在类外添加，提供这种能力的意义在于， 它可以让我们在不修改头文件里函数声明的情况下，改变函数内部的行 为

=delete与=default不同，它必须添加在类内部的函数声明中， 如果将其添加到类外部，那么会引发编译错误

将构造函数变为=default，类从非平凡类型恢复到平凡类型

针对禁止调用某些函数的问题，我们可以使用=delete来删除指定函数


## 显式删除的其他用法

显式删除不仅适用于类的成员函数，对于普通函数同样有效。只不 过相对于应用于成员函数，应用于普通函数的意义就不大了

显式删 除特定类的new运算符可以阻止该类在堆上动态创建对象

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240430205558.png)

可能会在单例模式中出现

## 总结

C++11标准中引入了显式默认和显式删除的方 法，这使我们可以精确地控制类特殊成员函数的生成以及删除，让过去 必须通过一些技巧间接实现的功能得到更加完美的实现。

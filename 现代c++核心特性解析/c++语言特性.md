
c++不仅具备面向对象的常规语言要素，如类 继承 多态 流 异常等机制，还包括诸多c++特有的语言要素，如多继承、复制构造、运算符重载、指针、引用、模板等

将数据和对数据的操作视为一个相互依赖 不可分割的对象，采用数据抽象和数据隐藏的技术



# 封装

类属性和类函数是分开存放的，类属性是用struct结构体来存放的，类函数是全局存放的

目的是把类的设计和使用分开来



# 继承

父类的私有属性会被继承并且占有空间


# 多态

同一消息为不同对象接受时可产生完全不同的行为

一个方法只有一个名字 但可以有多种形态，也就是程序中可以定义多个同名方法




# 内存分配情况

## 代码区

存储的是CPU执行的机器指令，通常是只读的


## 常量存储区

存放常量，通常是字符串常量和其他在程序中不会改变的值

## 全局/静态存储区

存放全局变量和静态变量，这些变量在程序的整个生命周期内都存在

## 堆

动态内存分配的区域，手动申请，手动释放，如果忘记释放，则会导致内存泄漏

## 栈

存放局部变量和函数调用信息
栈是自动管理的，局部变量在函数返回时自动释放

# 值传递与引用传递

值传递会产生拷贝副本
引用传递不会

如果想修改函数内形参值的同时修改原来值，则选择引用传递

引用传递如果是模版的话，则需要考虑const问题


# const

修饰符，告诉编译器被修饰的东西只读，const修饰的对象必须在定义时初始化

const类成员函数不能调用非const类成员函数

指向const变量的指针`const int *p*=&a`,可以改变指针指向，但不能改变指针指向的值

const指针` int* const p=&a` 不可以改变指针指向


![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240503100836.png)



# static

## 局部静态变量

生命周期是整个程序执行期间
一次定义，多次使用，且只能定义一次

## 全局静态变量

在文件作用域内定义的静态变量，它只对该文件可见，其他文件无法直接访问它，有助于实现信息封装

## 静态类成员

属于类本身，所有类的实例共享一个静态成员变量

## 静态函数

类内定义的静态函数，只能访问类的静态成员和其他静态成员函数，不能访问非静态成员。静态成员函数也不依赖于类的特定实例


# c vs c++

标准库
泛型编程
封装
继承
多态
设计哲学：面向对象/过程
内存管理：智能指针

# new/malloc delete/free

都是在堆上管理内存的方式

new更符合面向对象的思想，提供了更方便、安全的内存分配方式，并且支持构造函数的自动调用



## 返回对象
new 返回的是分配对象类型的指针
malloc 返回的是void* 类型指针，需要进行显式类型转换

## 构造函数
new会调用调用对象的构造函数，会自动初始化
malloc则不会，需手动调用构造函数


## 内存分配
new只需传入对象，根据对象自动计算大小
malloc需要显式指定所需内存大小

## 异常处理

new会抛出bad_alloc异常
malloc只返回NULL

# 指针与引用

## 初始化

指针可以不用初始化
引用必须初始化

## 可变性

指针的值可以改变
而引用的值不能改变

## 内存分配

指针本身需要分配内存
而引用不需要额外的内存分配，他只是变量的别名

## 用途

引用传参可以辨别拷贝

# 深浅拷贝

浅拷贝使用与源对象相同的内存地址，共享某些内存空间，修改可能影响源对象

当类内有涉及在堆空间的内存管理时，一般使用深拷贝


# 宏

在预处理阶段展开，仅仅是文本替换，没有类型检查
没有额外的内存开销

# 虚函数

用于实现多态

虚函数实现了动态绑定，在运行时根据对象类型来确定调用哪个函数
在基类声明为virtual，任何从基类派生的类都可以重写该函数

如果一个虚函数在基类中没有被定义，那么他被成为纯虚函数，在声明时通过添加=0来标识，含有纯虚函数的类被称为抽象类，他不能被实例化，抽象类的主要目的是作为其他类的基类，提供一组接口

每个包含虚函数的类中都会有一个虚函数表，该表存储量类中所有虚函数的地址

建议将基类的析构函数声明为虚函数


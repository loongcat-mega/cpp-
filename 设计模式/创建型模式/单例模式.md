


## 为什么要使用单例

- 处理资源访问冲突
- 表示全局唯一类


## 如何实现一个单例


全局只能有一个对象

### 饿汉模式

在类加载的时候，静态实例就已经创建并初始化好了，因此该方法是线程安全的，但是不支持延迟加载，占用资源较多

### 懒汉模式

支持延迟加载（用时加载），但是会出现并发操作的问题，如果加上锁（对方法加锁），会导致函数的并发度很低。如果频繁的调用，会导致性能瓶颈

```cpp
class Log
{
public:
    Log(const Log &log)=delete;
    Log& operator=(const Log& log)=delete;
    
    Log( Log &&log)=delete;  
    Log& operator=( Log&& log)=delete;
    
    static Log& get_instance()
    {
        call_once(once,init);
        return *log;
    }
    void print_err(const string& msg)
    {
        cout<<__TIME__<<" "<<msg<<endl;
    }
private:
    Log(){}
    inline static  Log *log=nullptr;
    inline static once_flag once;
    static void init()
    {
        if(log==nullptr)
            log=new Log();
    }
};
```

**禁用拷贝构造和拷贝复制构造
把默认构造函数权限改为private
利用类的静态成员函数返回唯一类对象**一类对象

如果实在是想获取对象，使用下面方法
```cpp
s3::Log && log=move(s3::Log::get_instance());
```
```cpp
int main()  
{  
    s3::Log && log=move(s3::Log::get_instance());  
    log.print_err("hello");  
    log.a=20;  
    s3::Log::get_instance().print_err("error");  
    cout<<&log<<","<<&s3::Log::get_instance()<<endl;  
    return 0;  
}
```
![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240504131039.png)

### 双重检测

在方法内加锁，既支持高并发，有支持延迟加载

### 静态内部类

静态私有方法


## 单例模式存在的问题

### 对OOP特性的支持不友好

对于一个单例对象的方法，如果某天要换一种实现，那所有用到该方法的地方都要修改，扩展性差

### 会隐藏类之间的依赖关系

### 对扩展性不友好

### 对可测试性不友好

### 不支持有参数的构造函数

## 单例模式总结

### 如何理解单例模式的唯一性

单例类对象的唯一性作用范围是进程唯一的：进程内唯一，进程间不唯一。进程唯一包含了线程间唯一

### 如何实现线程唯一的单例

使用map存储对象，key为线程id，value为对象



### 如何实现集群环境中的单例

把单例对象序列化并存储到外部共享存储区，进程在使用单例对象的时候，先将其读到内存，然后反序列化为对象。使用完成之后将其序列化并存储好外部共享存储区。
为了保证全局唯一，还要保证进程在获取到对象之后，对对象加锁，使用完之后对其解锁

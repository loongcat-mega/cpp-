

## 简单工厂

```java
public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);
    if (parser == null) {
      throw new InvalidRuleConfigException(
              "Rule config file format is not supported: " + ruleConfigFilePath);
    }

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

public class RuleConfigParserFactory {
  public static IRuleConfigParser createParser(String configFormat) {
    IRuleConfigParser parser = null;
    if ("json".equalsIgnoreCase(configFormat)) {
      parser = new JsonRuleConfigParser();
    } else if ("xml".equalsIgnoreCase(configFormat)) {
      parser = new XmlRuleConfigParser();
    } else if ("yaml".equalsIgnoreCase(configFormat)) {
      parser = new YamlRuleConfigParser();
    } else if ("properties".equalsIgnoreCase(configFormat)) {
      parser = new PropertiesRuleConfigParser();
    }
    return parser;
  }
}
```

根据不同的传入参数，创建不同的解析器。每次调用都要创建一个新的parser，如果为了节省内存和对象创建的时间，我们可以将parser事先创建好并缓存起来

```java
public class RuleConfigParserFactory {
  private static final Map<String, RuleConfigParser> cachedParsers = new HashMap<>();

  static {
    cachedParsers.put("json", new JsonRuleConfigParser());
    cachedParsers.put("xml", new XmlRuleConfigParser());
    cachedParsers.put("yaml", new YamlRuleConfigParser());
    cachedParsers.put("properties", new PropertiesRuleConfigParser());
  }

  public static IRuleConfigParser createParser(String configFormat) {
    if (configFormat == null || configFormat.isEmpty()) {
      return null;//返回null还是IllegalArgumentException全凭你自己说了算
    }
    IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
    return parser;
  }
}
```
## 工厂方法

```java

public interface IRuleConfigParserFactory {
  IRuleConfigParser createParser();
}

public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new JsonRuleConfigParser();
  }
}

public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new XmlRuleConfigParser();
  }
}

public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new YamlRuleConfigParser();
  }
}

public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFactory {
  @Override
  public IRuleConfigParser createParser() {
    return new PropertiesRuleConfigParser();
  }
}


public class RuleConfigSource {
  public RuleConfig load(String ruleConfigFilePath) {
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);

    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) {
      throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath);
    }
    IRuleConfigParser parser = parserFactory.createParser();

    String configText = "";
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  }

  private String getFileExtension(String filePath) {
    //...解析文件名获取扩展名，比如rule.json，返回json
    return "json";
  }
}

//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { //工厂的工厂
  private static final Map<String, IRuleConfigParserFactory> cachedFactories = new HashMap<>();

  static {
    cachedFactories.put("json", new JsonRuleConfigParserFactory());
    cachedFactories.put("xml", new XmlRuleConfigParserFactory());
    cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
    cachedFactories.put("properties", new PropertiesRuleConfigParserFactory());
  }

  public static IRuleConfigParserFactory getParserFactory(String type) {
    if (type == null || type.isEmpty()) {
      return null;
    }
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
    return parserFactory;
  }
}
```

当对象的创建逻辑比较复杂，不是简单new就可以，而是要组合其他对象，做各种初始化时，就要使用工厂方法


## 抽象工厂
抽象工厂模式的主要作用是解耦客户类在创建产品类时引入的耦合，将产品的创建过程从Client类中分离，通过使用一个类似于系统服务的工厂类来解决这个问题


抽象工厂模式包含以下几个核心角色：

    抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。
    具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。
    抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。
    具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。


```cpp
//
// Created by dlut2102 on 2024/5/6.
//
#include<iostream>
#include<memory>
#include<cassert>
using namespace std;
class PackBox;
class ChessFactory;
class ChessBoard;
//抽象工厂类，一系列工厂的抽象总称，比如棋类(抽象类)有象棋(具体类)，跳棋(具体类)等
class ChessFactory
{
public:
    ChessFactory()=default;
    //设置两个接口，负责对外输出每种棋类的特性
    virtual int getArea()=0;
    virtual ChessBoard* getChessBoard()=0;
    virtual ~ChessFactory(){};
};
class ChessBoard
{
public:
    virtual int getArea()=0;
    virtual ~ChessBoard(){};
};

namespace ChineseChess
{
    class ChineseChessBoard:public ChessBoard
    {
    public:
        ChineseChessBoard()=default;
        int getArea()override
        {
            return 10;
        }
        ~ChineseChessBoard()override
        {
            cout<<"this is ChineseChessBoard deconstruction\n";
        }
    };

//中国象棋具体工厂类
//包含两个项目 棋盘和价格
    class ChineseChessFactory:public ChessFactory
    {
        
        ChineseChessBoard* chinese_chess_board;
    public:
        using ChessFactory::ChessFactory;
        ChineseChessFactory()
        {
            chinese_chess_board=new ChineseChessBoard;
        }
        //ChineseChessFactory(int price_):price(price_){};

        int getArea()override
        {
            return chinese_chess_board->getArea();
        }
        ChessBoard* getChessBoard()override
        {
            return chinese_chess_board;
        }
        ~ChineseChessFactory()override
        {
            cout<<"this is deconstruction\n"<<endl;
        }

    };

}


//传入一个具体产品类
class PackBox
{
    unique_ptr<ChessFactory> factory;
    unique_ptr<ChessBoard> board;
public:
    PackBox()=default;
    PackBox( ChessFactory * cf )
    {
        assert(cf != nullptr);
        factory.reset(cf);
        board.reset(factory->getChessBoard());
    }
    int getArea()const
    {
        assert(factory != nullptr);
        return factory->getArea();
    }
    ~PackBox()
    {
        cout<<"this is PackBox deconstruction\n";
    }
    
};

int main()
{
    using namespace ChineseChess;
    unique_ptr<PackBox> pb = make_unique<PackBox>(new ChineseChessFactory);
    cout << pb->getArea()<<endl;
    return 0;
}

```

```txt
10
this is PackBox deconstruction
this is ChineseChessBoard deconstruction
this is deconstruction
```

在工厂模式中使用智能指针：
- 抽象类/基类使用裸指针
- 具体产品类也使用裸指针
- 只有在产品生产类里面(PackBox)和main使用智能指针





## 总结

当代码存在if-else分支，动态根据不同类型创建不同的对象时，可以使用工厂模式



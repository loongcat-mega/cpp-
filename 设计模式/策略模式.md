同一件事用不同的策略去实现
将每个策略包装为一个单独的类，这些类拥有相同的接口(继承自一个基类)、


```cpp
namespace Strategy
{
	//策略基类，对外提供接口
	class SortStrategyBase
	{
	public:
		virtual void sortStrategy()  = 0;
	};

	//不同策略的实现：
	class FastSort :public SortStrategyBase
	{
	public:
		void sortStrategy() override
		{
			cout << "this is fastsort\n";
		}
	};

	class GuluGuluSort :public SortStrategyBase
	{
	public:
		void sortStrategy() override
		{
			cout << "this is GuluGuluSort\n";
		}
	};

	class XierSort :public SortStrategyBase
	{
	public:
		void sortStrategy()  override
		{
			cout << "this is XierSort\n";
		}
	};

	//策略的应用类
	class Sort
	{
	public:
		//这里暂时还没想出好的办法，左值与右值传参的问题
		//既能接收named-object 也能接收 unnamed-object
		void Play(SortStrategyBase& SortBase)
		{
			SortBase.sortStrategy();
		}
		void Play(SortStrategyBase&& SortBase)
		{
			SortBase.sortStrategy();
		}
	};
	int main()
	{
		Sort so;
		so.Play(FastSort());
		so.Play(GuluGuluSort());
		so.Play(XierSort());
		return 0;
	}
}
```


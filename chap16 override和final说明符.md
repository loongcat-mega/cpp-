
## 重写、重载和隐藏

- 重写 override更接近于覆盖，在C++中是指派生类覆盖 了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型， 也就是说有相同的函数名、形参列表以及返回类型
- 重载 overload 它通常是指在同一个类中有两个或者两个以 上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形 参。这种情况在类的构造函数中最容易看到，为了让类更方便使用，我 们经常会重载多个构造函数
- 隐藏 overwrite 隐藏 是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时， 如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生 类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果 是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏。如果还想使用基类函数，可以使用using关键字将其引入派生类

```cpp
class A  
{  
public:  
    void foo(int){cout<<"A"<<endl;}  
};  
class B:public A  
{  
public:  
    void foo(char){cout<<"B overwrite"<<endl;}  
    void foo(int){cout<<"B override"<<endl;}  
};
```

## 重写引发的问题

重写 override要求重写的函数名与签名都与基类一致，如果写错了，编译器并不会报错


## 使用override说明符

C++11标准提供了一个非常 实用的override说明符，这个说明符必须放到虚函数的尾部，它明确告 诉编译器这个虚函数需要覆盖基类的虚函数。一旦编译器发现该虚函数 不符合重写规则，就会给出错误提示

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240501221629.png)


## 使用final说明符

在C++中，我们可以为基类声明纯虚函数来迫使派生类继承并且重 写这个纯虚函数。但是一直以来，C++标准并没有提供一种方法来阻止 派生类去继承基类的虚函数。C++11标准引入final说明符解决了上述问 题，**它告诉编译器该虚函数不能被派生类重写**。final说明符用法和 override说明符相同，需要声明在虚函数的尾部。

final说明符可以修饰最底层基类的虚 函数而override则不行，所以在这个例子中final可以声明基类Base的虚 函数foo，只不过我们通常不会这样做

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240501221808.png)


有时候，override和final会同时出现。这种情况通常是由中间派生类 继承基类后，希望后续其他派生类不能修改本类虚函数的行为而产生 的

final说明符不仅能声明虚函数，还可以声明类。 如果在类定义的时候声明了final，那么这个类将不能作为基类被其他类 继承

![image.png](https://yaaame-1317851743.cos.ap-beijing.myqcloud.com/20240501221917.png)


## 总结
override说明符，它指明类的成员函数必须是一个 重写函数，要求编译器检查派生类中的虚函数确实重写了基类中的函 数，否则就会引发一个编译错误。通常来说，我们应该用override说明 有重写意图的虚函数

final阻止继承类重写该方法
本仓库记录了现代c语言核心特性解析的一些笔记

利用命名空间可以在同一个文件内，写多个main函数，实现多个功能？类似于java类中的main？要调用那个，只需调用相应命名空间

auto+decltype+返回类型后置可以完成一些模版的编写和完善

右值引用引入了移动语义，由拷贝转为移动，节省了效率，std::move()可以让左值使用移动语义，完成内存的移动操作

lambda表达式个人多用在algorithm中的一些函数上，比如 sort ，find_if等

非静态数据成员默认初始化与委托构造函数都是针对成员的初始化问题，减少构造函数冗余

参数列表初始化多用在stl容器的初始化中

默认和删除函数让类具有某些特性，如不可拷贝，不可在堆空间生成等


- 内联和命名空间
    - 解决命名冲突问题
    - 更好省级维护代码
- auto占位符
    - 自动推导类型，但是c++20之前不能做形参
    - 与下面decltype和返回类型后置，使模版更加灵活易用
    - lambda表达式用auto接收
- decltype说明符
    - 根据规则获取操作数的类型
    - 对库作者友好
- 函数返回类型后置
    - 与上面auto+decltype结合使用
- 左值与右值引用
    - 右值不能取址
    - 函数返回值一般都是右值，可以初始化左值，但是当涉及类时，如果把一个右值传进左值引用的形参列表，会产生错误，解决方法：常量左值引用/右值引用
    - 右值引用引入了移动构造函数，因为右值生存期很短，没必要浪费时间再拷贝一份对象，所以可以直接移动资源，但可能会出现异常
    - 在右值初始化左值时，c++11默认会调用移动方式而不是拷贝方式
    - 左值属性变为右值可以提升效率
- lambda表达式
    - lambda是一个类，有着自己的成员属性
    - 捕获列表，只能捕获非静态局部变量
    - 按值/按引用捕获，按值不修改值(mutable)，按引用修改值
    - 与stl结合较多
- 非静态数据成员默认初始化
    - 在定义时直接赋初值，减少了构造函数冗余问题
- 列表初始化
    - 更多用在容器
    - 如果实在变量上，要注意隐式缩窄转换问题
- 默认和删除函数
    - 精准控制类成员函数的生成和删除
    - 比如不允许一个类进行拷贝和赋值，就显式删除其相应构造函数
- 委托构造函数
    - 解决构造函数冗余问题
    - 层层代理，委托构造函数让代理构造函数替自己完成构造，如果有新增参数，只需修改代理构造函数即可

